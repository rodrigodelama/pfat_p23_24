package Parser;

import java_cup.runtime.*;
import AST.*;

parser code {:
  public void syntax_error(Symbol s) {
    report_error("Error de sintaxis en linea " + s.left, null);
  }
  

  public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception {
    report_fatal_error("", null);
  }
:};

/*
  DEFINICIÓN DE LA GRAMÁTICA:

  G=<ET, EN, S, P>
  ET= {COMA, PC, PAREN, TESIS, BEGIN, END, ASIG, AND, OR, NOT, 
      IF, THEN, PROG, DECL, WHILE, DO, PRINT_I, PRINT_B, BRAC, KET, 
      IN, UNION, INTERSEC, CARD, LOWEST_ELEM, MAS, MENOS, MUL, 
      DIV, MAYOR, MENOR, IGUAL, IDENT, CLOG, CINT, :t, EMPTYSET}
  EN= {S, <IdentList>, <StatementList>, <Body>, <Statement>,
      <Exp>, <LDecl>, <Decl>}
  S= S
  P= {
    S->  PROG IDENT DECL <LDecl> <Body> 
      |  PROG IDENT <Body> 
    <LDecl>-> <Decl> PC
          | <Decl> PC <LDecl>
    <Decl>-> :t <IdentList>
    <IdentList>-> IDENT
              | IDENT COMA <IdentList>
    <Body>-> BEGIN <StatementList> END PC
    <StatementList>-> <Statement> PC 
                  | <Statement> PC <StatementList>
    <Statement>-> IDENT ASIG <Exp> 
              | PRINT_I PAREN IDENT TESIS 
              | PRINT_B PAREN IDENT TESIS 
              | IF <Exp> THEN <StatementList> END 
              | WHILE <Exp> DO <StatementList> END  
    <Exp>-> 
  }
*/

// Terminales
terminal COMA, PC, PAREN, TESIS, BEGIN, END, ASIG, AND, OR, NOT, IF, THEN, PROG,
          DECL, WHILE, DO, PRINT_I, PRINT_B, BRAC, KET, IN, UNION, INTERSEC, CARD,
          LOWEST_ELEM, MAS, MENOS, MUL, DIV, MAYOR, MENOR, IGUAL, IDENT, CLOG, CINT,
          :t, EMPTYSET;//, IDENT, OPUESTO; // revisar si es correcto añadir IDENT, OPUESTO

// No terminales
non terminal pf2024 pf2024;
non terminal LDecl LDecl;
non terminal Decl Decl;
non terminal IdentList IdentList;
non terminal Body Body;
non terminal StatementList StatementList;
non terminal Statement Statement; 
non terminal Exp Exp; // hay que definir Exp

/*
  Reglas de precedencia
  La precedencia de los operadores es, de menor a mayor:
  1. union
  2. intersec
  3. in
  4. or
  5. and
  6. not
  7. =
  8. < y >
  9. + y -
  10. * y /
  11. - (opuesto)
*/

precedence UNION;
precedence INTERSEC;
precedence IN;
precedence OR;
precedence AND;
precedence NOT;
precedence IGUAL;
precedence MENOR MAYOR;
precedence MAS MENOS;
precedence MUL DIV;
precedence MENOS; // - (opuesto)

// Reglas de producción

start with pf2024; // Simbolo Inicial

pf2024 ::= PROG IDENT:i DECL:d LDecl:ld Body:b {:RESULT=new Prog(i, d, ld, b); :} 
         | PROG IDENT:i Body:b {:RESULT=new Prog($2, $3); :} ;
LDecl ::= Decl:d PC {:RESULT=new LDecl1(d); :}
        | Decl:d PC LDecl:ld {:RESULT=new LDecl2(d, ld); :} ;
Decl ::= TYPE:t IdentList:il {:RESULT=new Decl(t, il); :} ;
IdentList ::= IDENT:i {:RESULT=new IdentList1(i); :}
            | IDENT:i COMA IdentList:il {:RESULT=new IdentList2(i, il); :} ;
Body ::= BEGIN StatementList:sl END PC {:RESULT=new Body(sl); :} ;
StatementList ::= Statement:s PC {:RESULT=new StatementList1(s); :}
                | Statement:s PC StatementList:sl {:RESULT=new StatementList2(s, sl); :} ;
Statement ::= IDENT:i ASIG Exp:e {:RESULT=new Statement1(i, e); :}
            | PRINT_I PAREN IDENT:i TESIS {:RESULT=new Statement2(i); :}
            | PRINT_B PAREN IDENT:i TESIS {:RESULT=new Statement3(i); :}
            | IF Exp:e THEN StatementList:sl END {:RESULT=new Statement4(e, sl); :}
            | WHILE Exp:e DO StatementList:sl END {:RESULT=new Statement5(e, sl); :} ;
// definir Exp:
      //Expresiones sin tipo definido
Exp ::= IDENT:s {:RESULT=new Variable(s); :} //Un identificador que sea el nombre de una variable. Será del tipo de la variable.
      | PAREN Exp:e TESIS {:RESULT=new Parentesis(e); :} //Una expresión entre paréntesis. Será del tipo de la expresión contenida dentro de los paréntesis.
      //Expresiones de tipo int
      | CINT:n {:RESULT=new ConstanteEntera(n.intValue()); :} //Una constante expresada en decimal.
      | Exp:e1 MAS Exp:e2 {:RESULT=new Suma(e1, e2); :} //Una suma de expresiones de tipo int utilizando el operador "+".
      | Exp:e1 MENOS Exp:e2 {:RESULT=new Menos(e1, e2); :} //Una resta de expresiones de tipo int utilizando el operador "-".
      | Exp:e1 MUL Exp:e2 {:RESULT=new Multiplicacion(e1, e2); :} //Una multiplicación de expresiones de tipo int utilizando el operador "*".
      | Exp:e1 DIV Exp:e2 {:RESULT=new Division(e1, e2); :} //Una división de expresiones de tipo int utilizando el operador "/".
      | MENOS Exp:e {:RESULT=new Opuesto(e); :} //El opuesto de una expresión de tipo int, utilizando el símbolo habitual "-" antes de la expresión.
      | CARD PAREN Exp:e TESIS {:RESULT=new Card(e); :} //El número de elementos de un conjunto de enteros, utilizando la función card.
      | LOWEST_ELEM PAREN Exp:e TESIS {:RESULT=new LowestElem(e); :} //El menor elemento de un conjunto de enteros, utilizando la función lowest_elem.
          //Nota: el código generado en la práctica 3 debe lanzar una excepcióncuando lowest_elem sea aplicado al conjunto vacío.
      //Expresiones de tipo intset (conjunto de enteros)
      | EMPTYSET {:RESULT=new ConjuntoVacio(); :} //Un conjunto vacío.
      | BRAC ExpList:k KET {:RESULT=new Conjunto(k); :} //Un conjunto de enteros, utilizando los símbolos "{" y "}" para delimitar la lista de elementos.
          //TODO: Repasar ExpList, tiene senttido?
      | Exp:e1 UNION Exp:e2 {:RESULT=new Union(e1, e2); :} //La unión de dos conjuntos de enteros, utilizando el operador union.
      | Exp:e1 INTERSEC Exp:e2 {:RESULT=new Interseccion(e1, e2); :} //La intersección de dos conjuntos de enteros, utilizando el operador intersec.
          //TODO: Repasar Diff: la diferencia de conjuntos A - B es el conjunto que está formado por aquellos elementos de A que no pertenecen a B.
      | Exp:e1 MENOS Exp:e2 {:RESULT=new Diferencia(e1, e2); :} //La diferencia de dos conjuntos de enteros, utilizando el operador "-".
      
      //Expresiones de tipo bool
      | CLOG:c {:RESULT=new ConstanteBooleana(c.booleanValue()); :} //Una constante de tipo bool.
      | Exp:e1 AND Exp:e2 {:RESULT=new And(e1, e2); :} //La conjunción de dos expresiones lógicas, utilizando el operador and.
      | Exp:e1 OR Exp:e2 {:RESULT=new Or(e1, e2); :} //La disyunción de dos expresiones lógicas, utilizando el operador or.
      | NOT Exp:e1 {:RESULT=new Not(e1); :} //Una expresión lógica negada, utilizando el operador not antes de la expresión lógica.
      | Exp:e1 IGUAL Exp:e2 {:RESULT=new Igual(e1, e2); :} //La igualdad entre dos expresiones, utilizando el operador "=".
      | Exp:e1 MENOR Exp:e2 {:RESULT=new Menor(e1, e2); :} //La comparación entre 2 expresiones de tipo int utilizando el operador "<" (menor que).
      | Exp:e1 MAYOR Exp:e2 {:RESULT=new Mayor(e1, e2); :} //La comparación entre 2 expresiones de tipo int utilizando el operador ">".
      | Exp:e1 IN Exp:e2 {:RESULT=new In(e1, e2); :} //Una expresión que pertenezca al lenguaje definido por la expresión lingüística <Exp> in <Exp>
                                                    //donde la primera subexpresión ha de ser de tipo int y la segunda de tipo intset. Devuelve true
                                                    //si el entero resultado de evaluar la primera subexpresión pertenece al conjunto resultado de
                                                    //evaluar la segunda y false en caso contrario.

//Nota: para definir las expresiones puede ser necesario definir algún símbolo no terminal adicional en la gramática.
