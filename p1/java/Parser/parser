package Parser;

import java_cup.runtime.*;
import AST.*;

parser code {:
  public void syntax_error(Symbol s) {
    report_error("Error de sintaxis en linea " + s.left, null);
  }

  public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception {
    report_fatal_error("", null);
  }
:};

/*
  DEFINICIÓN DE LA GRAMÁTICA:

  G=<ET, EN, S, P>
  ET= {COMA, PC, PAREN, TESIS, BEGIN, END, ASIG, AND, OR, NOT, 
      IF, THEN, PROG, DECL, WHILE, DO, PRINT_I, PRINT_B, BRAC, KET, 
      IN, UNION, INTERSEC, CARD, LOWEST_ELEM, MAS, MENOS, MUL, 
      DIV, MAYOR, MENOR, IGUAL, IDENT, CLOG, CINT, :t, EMPTYSET}
  EN= {S, <IdentList>, <StatementList>, <Body>, <Statement>,
      <Exp>, <LDecl>, <Decl>}
  S= S
  P= {
    S->  PROG IDENT DECL <LDecl> <Body> 
      |  PROG IDENT <Body> 
    <LDecl>-> <Decl> PC
          | <Decl> PC <LDecl>
    <Decl>-> TYPE <IdentList>
    <IdentList>-> IDENT
              | IDENT COMA <IdentList>
    <Body>-> BEGIN <StatementList> END PC
    <StatementList>-> <Statement> PC 
                  | <Statement> PC <StatementList>
    <Statement>-> IDENT ASIG <Exp> 
              | PRINT_I PAREN IDENT TESIS 
              | PRINT_B PAREN IDENT TESIS 
              | IF <Exp> THEN <StatementList> END 
              | WHILE <Exp> DO <StatementList> END

    TODO: review ExpList - seems reasonable but compare with statement list
    <ExpList>-> <Exp> 
            | <Exp> COMA <ExpList>

    TODO: review Exp - copilot did this list below
    <Exp>-> IDENT 
          | PAREN <Exp> TESIS 
          | CINT 
          | <Exp> MAS <Exp> 
          | <Exp> MENOS <Exp> 
          | <Exp> MUL <Exp> 
          | <Exp> DIV <Exp> 
          | MENOS <Exp> 
          | CARD PAREN <Exp> TESIS 
          | LOWEST_ELEM PAREN <Exp> TESIS 
          | EMPTYSET 
          | BRAC <ExpList> KET 
          | <Exp> UNION <Exp> 
          | <Exp> INTERSEC <Exp> 
          | <Exp> IN <Exp> 
          | CLOG 
          | <Exp> AND <Exp> 
          | <Exp> OR <Exp> 
          | NOT <Exp> 
          | <Exp> IGUAL <Exp>
  }
*/

// Terminales
terminal COMA, PC, PAREN, TESIS, BEGIN, END, ASIG, AND, OR, NOT, IF, THEN, PROG,
          DECL, WHILE, DO, PRINT_I, PRINT_B, BRAC, KET, IN, UNION, INTERSEC, CARD,
          LOWEST_ELEM, MAS, MENOS, MUL, DIV, MAYOR, MENOR, IGUAL, EMPTYSET, OPUESTO;

terminal Integer CINT, TYPE;
terminal String IDENT;
terminal Boolean CLOG;

// Conflictos de reducción
//COMA, PC, TESIS, AND, OR, THEN, DO, KET, IN, UNION, INTERSEC, MAS, MENOS, MUL, DIV, MAYOR, MENOR, IGUAL

// No terminales - padres de subclases
non terminal Prog Prog;
non terminal IdentList IdentList;
non terminal StatementList StatementList;
non terminal Body Body;
non terminal Statement Statement; //stsimp o lo que sea //una interfaz para cada no terminal
non terminal Exp Exp; // hay que definir Exp
non terminal LDecl LDecl;
non terminal Decl Decl;
non terminal ExpList ExpList; // hay que definir ExpList tambien

/*
  La precedencia de los operadores es, de menor a mayor:
  1. union
  2. intersec
  3. in
  4. or
  5. and
  6. not
  7. =
  8. < y >
  9. + y -
  10. * y /
  11. - (opuesto)
  Todos los operadores asocian por la izquierda.
*/

// Reglas de precedencia
precedence left UNION;
precedence left INTERSEC;
precedence left IN;
precedence left OR;
precedence left AND;
precedence left NOT;
precedence left IGUAL;
precedence left MENOR, MAYOR;
precedence left MAS, MENOS;
precedence left MUL, DIV;
precedence left OPUESTO; // - (opuesto)

// Reglas de producción O SON Experesiones regulares ???

start with Prog; // Simbolo Inicial
//check
Prog ::= PROG IDENT:i Decl:d LDecl:ld Body:b {:RESULT=new Prog1(i, d, ld, b); :} 
         | PROG IDENT:i Body:b {:RESULT=new Prog2(i, b); :} ;
//check
LDecl ::= Decl:d PC {:RESULT=new LDecl1(d); :}
        | Decl:d PC LDecl:ld {:RESULT=new LDecl2(d, ld); :} ;
//check
Decl ::= TYPE:t IdentList:il {:RESULT=new Decl(t.intValue(), il); :} ;
//check
IdentList ::= IDENT:i {:RESULT=new IdentList1(i); :}
            | IDENT:i COMA IdentList:il {:RESULT=new IdentList2(i, il); :} ;
//check
Body ::= BEGIN StatementList:sl END PC {:RESULT=new Body(sl); :} ;
//check
StatementList ::= Statement:s PC {:RESULT=new StatementList1(s); :}
                | Statement:s PC StatementList:sl {:RESULT=new StatementList2(s, sl); :} ;
//check
Statement ::= IDENT:i ASIG Exp:e {:RESULT=new Statement1(i, e); :}
            | PRINT_I PAREN IDENT:i TESIS {:RESULT=new Statement2(i); :}
            | PRINT_B PAREN IDENT:i TESIS {:RESULT=new Statement3(i); :}
            | IF Exp:e THEN StatementList:sl END {:RESULT=new Statement4(e, sl); :}
            | WHILE Exp:e DO StatementList:sl END {:RESULT=new Statement5(e, sl); :} ;
// definir ExpList: 
      //Lista de expresiones
// had to make this
//check
ExpList ::= Exp:e {:RESULT=new ExpList1(e); :}
          | Exp:e COMA ExpList:el {:RESULT=new ExpList2(e, el); :} ;
// definir Exp:
//check
      //Expresiones sin tipo definido
Exp ::= IDENT:s {:RESULT=new Variable(s); :} //Un identificador que sea el nombre de una variable. Será del tipo de la variable.
      | PAREN Exp:e TESIS {:RESULT=new Parentesis(e); :} //Una expresión entre paréntesis. Será del tipo de la expresión contenida dentro de los paréntesis.
      
      //Expresiones de tipo int
      | CINT:n {:RESULT=new ConstanteEntera(n.intValue()); :} //Una constante expresada en decimal.
      | Exp:e1 MAS Exp:e2 {:RESULT=new Suma(e1, e2); :} //Una suma de expresiones de tipo int utilizando el operador "+".
      | Exp:e1 MENOS Exp:e2 {:RESULT=new Resta(e1, e2); :} //Una resta de expresiones de tipo int utilizando el operador "-".
      | Exp:e1 MUL Exp:e2 {:RESULT=new Multiplicacion(e1, e2); :} //Una multiplicación de expresiones de tipo int utilizando el operador "*".
      | Exp:e1 DIV Exp:e2 {:RESULT=new Division(e1, e2); :} //Una división de expresiones de tipo int utilizando el operador "/".
      | MENOS Exp:e {:RESULT=new Opuesto(e); :} %prec OPUESTO //El opuesto de una expresión de tipo int, utilizando el símbolo habitual "-" antes de la expresión.
      | CARD PAREN Exp:e TESIS {:RESULT=new Card(e); :} //El número de elementos de un conjunto de enteros, utilizando la función card.
      | LOWEST_ELEM PAREN Exp:e TESIS {:RESULT=new LowestElem(e); :} //El menor elemento de un conjunto de enteros, utilizando la función lowest_elem.
          //Nota: el código generado en la práctica 3 debe lanzar una excepcióncuando lowest_elem sea aplicado al conjunto vacío.
      
      //Expresiones de tipo intset (conjunto de enteros)
      | EMPTYSET {:RESULT=new ConjuntoVacio(); :} //Un conjunto vacío.
              /*
                Una expresión que comienza por {, termina por } y contiene una lista de subexpresiones de tipo int,
                separadas por comas. Representa un conjunto de enteros cuyos elementos son los enteros resultado de
                evaluar las subexpresiones.
              */
      | BRAC ExpList:el KET {:RESULT=new Conjunto(el); :} //Un conjunto de enteros, utilizando los símbolos "{" y "}" para delimitar la lista de elementos.
          //TODO: Repasar ExpList, tiene sentido?
      | Exp:e1 UNION Exp:e2 {:RESULT=new Union(e1, e2); :} //La unión de dos conjuntos de enteros, utilizando el operador union.
      | Exp:e1 INTERSEC Exp:e2 {:RESULT=new Interseccion(e1, e2); :} //La intersección de dos conjuntos de enteros, utilizando el operador intersec.
          // La diferencia es tan facil como A - B pero CON TRUCO //FIXME:
          // ES ESTO DIFF(A, B) = A - B
          //// NO ES ESTO DIFF(A, B) = A - (A INTERSEC B)
      // | Exp:e1 MENOS Exp:e2 {:RESULT=new Diferencia(e1, e2); :} //La diferencia de dos conjuntos de enteros, utilizando el operador "-".
      
      //Expresiones de tipo bool
      | CLOG:c {:RESULT=new ConstanteBooleana(c.booleanValue()); :} //Una constante de tipo bool.
      | Exp:e1 AND Exp:e2 {:RESULT=new And(e1, e2); :} //La conjunción de dos expresiones lógicas, utilizando el operador and.
      | Exp:e1 OR Exp:e2 {:RESULT=new Or(e1, e2); :} //La disyunción de dos expresiones lógicas, utilizando el operador or.
      | NOT Exp:e1 {:RESULT=new Not(e1); :} //Una expresión lógica negada, utilizando el operador not antes de la expresión lógica.
      | Exp:e1 IGUAL Exp:e2 {:RESULT=new Igual(e1, e2); :} //La igualdad entre dos expresiones, utilizando el operador "=".
      | Exp:e1 MENOR Exp:e2 {:RESULT=new Menor(e1, e2); :} //La comparación entre 2 expresiones de tipo int utilizando el operador "<" (menor que).
      | Exp:e1 MAYOR Exp:e2 {:RESULT=new Mayor(e1, e2); :} //La comparación entre 2 expresiones de tipo int utilizando el operador ">".
      | Exp:e1 IN Exp:e2 {:RESULT=new In(e1, e2); :} ;//Una expresión que pertenezca al lenguaje definido por la expresión lingüística <Exp> in <Exp>
                                                      //donde la primera subexpresión ha de ser de tipo int y la segunda de tipo intset. Devuelve true
                                                      //si el entero resultado de evaluar la primera subexpresión pertenece al conjunto resultado de
                                                      //evaluar la segunda y false en caso contrario.

//Nota: para definir las expresiones puede ser necesario definir algún símbolo no terminal adicional en la gramática.
