/*
 * Procesamiento de Formatos en Aplicaciones Telem치ticas
 * Pr치ctica 1
 * 
 * Rodrigo De Lama Fern치ndez - 100451775
 * Isabel Schweim - 100460211
 * 
 * parser
 */

package Parser;

import java_cup.runtime.*;
import AST.*;

parser code {:
  public void syntax_error(Symbol s) {
    report_error("Error de sintaxis en linea " + s.left + "\n\n", null);
  }

  public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception {
    report_fatal_error("", null);
  }
:};

// Terminales
terminal COMA, PC, PAREN, TESIS, BEGIN, END, ASIG, AND, OR, NOT, IF, THEN, PROG,
          DECL, WHILE, DO, PRINT_I, PRINT_B, BRAC, KET, IN, UNION, INTERSEC, CARD,
          LOWEST_ELEM, MAS, MENOS, MUL, DIV, MAYOR, MENOR, IGUAL, EMPTYSET, OPUESTO;
terminal Integer CINT, TYPE;
terminal String IDENT;
terminal Boolean CLOG;

// No terminales
non terminal Prog Prog;
non terminal IdentList IdentList;
non terminal StatementList StatementList;
non terminal Body Body;
non terminal Statement Statement;
non terminal Exp Exp;
non terminal LDecl LDecl;
non terminal Decl Decl;
non terminal ExpList ExpList;

// Reglas de precedencia
precedence left UNION;
precedence left INTERSEC;
precedence left IN;
precedence left OR;
precedence left AND;
precedence left NOT;
precedence left IGUAL;
precedence left MENOR, MAYOR;
precedence left MAS, MENOS;
precedence left MUL, DIV;
precedence left OPUESTO; // - (opuesto)

start with Prog; // Simbolo Inicial

// Reglas de producci칩n
Prog ::= PROG IDENT:i DECL LDecl:ld Body:b {:RESULT=new Prog1(i, ld, b); :} 
       | PROG IDENT:i Body:b {:RESULT=new Prog2(i, b); :} ;

LDecl ::= Decl:d PC {:RESULT=new LDecl1(d); :}
        | Decl:d PC LDecl:ld {:RESULT=new LDecl2(d, ld); :} ;

Decl ::= TYPE:t IdentList:il {:RESULT=new Decl(t.intValue(), il); :} ;

IdentList ::= IDENT:i {:RESULT=new IdentList1(i); :}
            | IDENT:i COMA IdentList:il {:RESULT=new IdentList2(i, il); :} ;

Body ::= BEGIN StatementList:sl END PC {:RESULT=new Body(sl); :} ;

StatementList ::= Statement:s PC {:RESULT=new StatementList1(s); :}
                | Statement:s PC StatementList:sl {:RESULT=new StatementList2(s, sl); :} ;

Statement ::= IDENT:i ASIG Exp:e {:RESULT=new Statement1(i, e); :}
            | PRINT_I PAREN IDENT:i TESIS {:RESULT=new Statement2(i); :}
            | PRINT_B PAREN IDENT:i TESIS {:RESULT=new Statement3(i); :}
            | IF Exp:e THEN StatementList:sl END {:RESULT=new Statement4(e, sl); :}
            | WHILE Exp:e DO StatementList:sl END {:RESULT=new Statement5(e, sl); :} ;

ExpList ::= Exp:e {:RESULT=new ExpList1(e); :}
          | Exp:e COMA ExpList:el {:RESULT=new ExpList2(e, el); :} ;

      //Expresiones sin tipo definido
Exp ::= IDENT:s {:RESULT=new Variable(s); :}
      | PAREN Exp:e TESIS {:RESULT=new Parentesis(e); :}
      //Expresiones de tipo int
      | CINT:n {:RESULT=new ConstanteEntera(n.intValue()); :}
      | Exp:e1 MAS Exp:e2 {:RESULT=new Suma(e1, e2); :}
      | Exp:e1 MENOS Exp:e2 {:RESULT=new RestaODiff(e1, e2); :}
      | Exp:e1 MUL Exp:e2 {:RESULT=new Multiplicacion(e1, e2); :}
      | Exp:e1 DIV Exp:e2 {:RESULT=new Division(e1, e2); :}
      | MENOS Exp:e {:RESULT=new Opuesto(e); :} %prec OPUESTO
      | CARD PAREN Exp:e TESIS {:RESULT=new Card(e); :}
      | LOWEST_ELEM PAREN Exp:e TESIS {:RESULT=new LowestElem(e); :}
      //Expresiones de tipo intset (conjunto de enteros)
      | BRAC KET {:RESULT=new ConjuntoVacio(); :}
      | EMPTYSET {:RESULT=new ConjuntoVacio(); :}
      | BRAC ExpList:el KET {:RESULT=new Conjunto(el); :}
      | Exp:e1 UNION Exp:e2 {:RESULT=new Union(e1, e2); :}
      | Exp:e1 INTERSEC Exp:e2 {:RESULT=new Interseccion(e1, e2); :}
      //Expresiones de tipo bool
      | CLOG:c {:RESULT=new ConstanteBooleana(c.booleanValue()); :}
      | Exp:e1 AND Exp:e2 {:RESULT=new And(e1, e2); :}
      | Exp:e1 OR Exp:e2 {:RESULT=new Or(e1, e2); :}
      | NOT Exp:e1 {:RESULT=new Not(e1); :}
      | Exp:e1 IGUAL Exp:e2 {:RESULT=new Igual(e1, e2); :}
      | Exp:e1 MENOR Exp:e2 {:RESULT=new Menor(e1, e2); :}
      | Exp:e1 MAYOR Exp:e2 {:RESULT=new Mayor(e1, e2); :}
      | Exp:e1 IN Exp:e2 {:RESULT=new In(e1, e2); :} ;
